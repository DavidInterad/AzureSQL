/* Azure SQL Maintenance - Maintenance script for Azure SQL Database */
/* This script provided AS IS, Please review the code before executing this on production environment */
/* For any issue or suggestion please email to: yocr@microsoft.com */
/* 
***********************************************
	Current Version Date: 2021-05-03
***********************************************

Change Log: 
	
	2021-05-03	+ add support for per schema maintenance
		
	2021-05-02	+ Added support for "per partition" rebuild / reorg
				+ added filter for  User tables and views for index maintenance 
	2020-01-07
				+ some bug fixes - see GitHub for more information 
*/

IF OBJECT_ID('dbo.AzureSQLMaintenance') IS NULL
    EXEC ('create procedure AzureSQLMaintenance as /*dummy procedure body*/ select 1;');
GO
ALTER PROCEDURE [dbo].[AzureSQLMaintenance]
(
    @operation NVARCHAR(10) = NULL,
    @mode NVARCHAR(10) = 'smart',
    @ResumableIndexRebuild BIT = 0,
    @RebuildHeaps BIT = 0,
    @LogToTable BIT = 0,
    @WorkOnSchema sysname = NULL,
    @debug NVARCHAR(20) = 'none' /* Optional values: 'none', 'whatif'*/
)
AS
BEGIN
    SET NOCOUNT ON;

    ---------------------------------------------
    --- Varialbles and pre conditions check
    ---------------------------------------------

    SET QUOTED_IDENTIFIER ON;
    DECLARE @idxIdentifierBegin CHAR(1),
            @idxIdentifierEnd CHAR(1);
    DECLARE @statsIdentifierBegin CHAR(1),
            @statsIdentifierEnd CHAR(1);

    DECLARE @msg NVARCHAR(MAX);
    DECLARE @minPageCountForIndex INT = 40;
    DECLARE @OperationTime DATETIME2 = SYSDATETIME();
    DECLARE @KeepXOperationInLog INT = 3;
    DECLARE @ScriptHasAnError INT = 0;
    DECLARE @ResumableIndexRebuildSupported INT;
    DECLARE @indexStatsMode sysname;

    /* make sure parameters selected correctly */
    SET @operation = LOWER(@operation);
    SET @mode = LOWER(@mode);
    SET @debug = LOWER(@debug); /* any value at this time will produce the temp tables as permanent tables */

    IF @mode NOT IN ( 'smart', 'dummy' )
        SET @mode = 'smart';

    ---------------------------------------------
    --- Begin
    ---------------------------------------------

    IF @operation NOT IN ( 'index', 'statistics', 'all' )
       OR @operation IS NULL
    BEGIN
        RAISERROR('@operation (varchar(10)) [mandatory]', 0, 0);
        RAISERROR(' Select operation to perform:', 0, 0);
        RAISERROR('     "index" to perform index maintenance', 0, 0);
        RAISERROR('     "statistics" to perform statistics maintenance', 0, 0);
        RAISERROR('     "all" to perform indexes and statistics maintenance', 0, 0);
        RAISERROR(' ', 0, 0);
        RAISERROR('@mode(varchar(10)) [optional]', 0, 0);
        RAISERROR(' optionaly you can supply second parameter for operation mode: ', 0, 0);
        RAISERROR('     "smart" (Default) using smart decision about what index or stats should be touched.', 0, 0);
        RAISERROR(
                     '     "dummy" going through all indexes and statistics regardless thier modifications or fragmentation.',
                     0,
                     0
                 );
        RAISERROR(' ', 0, 0);
        RAISERROR('@ResumableIndexRebuild(bit) [optional]', 0, 0);
        RAISERROR(' optionaly you can choose to rebuild indexes as resumable operation: ', 0, 0);
        RAISERROR('     "0" (Default) using non resumable index rebuild.', 0, 0);
        RAISERROR('     "1" using resumable index rebuild when it is supported.', 0, 0);
        RAISERROR(' ', 0, 0);
        RAISERROR('@RebuildHeaps(bit) [optional]', 0, 0);
        RAISERROR(' Logging option: @LogToTable(bit)', 0, 0);
        RAISERROR('     0 - (Default) do not log operation to table', 0, 0);
        RAISERROR('     1 - log operation to table', 0, 0);
        RAISERROR(
                     '		for logging option only 3 last execution will be kept by default. this can be changed by easily in the procedure body.',
                     0,
                     0
                 );
        RAISERROR('		Log table will be created automatically if not exists.', 0, 0);
        RAISERROR(' ', 0, 0);
        RAISERROR('@LogToTable(bit) [optional]', 0, 0);
        RAISERROR(' Rebuild HEAPS to fix forwarded records issue on tables with no clustered index', 0, 0);
        RAISERROR('     0 - (Default) do not rebuild heaps', 0, 0);
        RAISERROR('     1 - Rebuild heaps based on @mode parameter, @mode=dummy will rebuild all heaps', 0, 0);
        RAISERROR(' ', 0, 0);
        RAISERROR('Example:', 0, 0);
        RAISERROR('		exec  AzureSQLMaintenance ''all'', @LogToTable=1', 0, 0);

    END;
    ELSE
    BEGIN

        ---------------------------------------------
        --- Validate Schema name if provided
        ---------------------------------------------
        IF @WorkOnSchema IS NOT NULL
           AND NOT EXISTS
        (
            SELECT *
            FROM sys.schemas
            WHERE [name] = @WorkOnSchema
        )
        BEGIN
            RAISERROR(
                         'Provided schema name does not exists - please make sure the correct schema name is provided',
                         16,
                         1
                     );
            RETURN 1;
        END;

        ---------------------------------------------
        --- Prepare log table
        ---------------------------------------------

        /* Prepare Log Table */
        IF OBJECT_ID('dbo.AzureSQLMaintenanceLog') IS NULL
           AND @LogToTable = 1
        BEGIN
            CREATE TABLE dbo.AzureSQLMaintenanceLog
            (
                id BIGINT PRIMARY KEY IDENTITY(1, 1),
                OperationTime DATETIME2,
                command VARCHAR(4000),
                ExtraInfo VARCHAR(4000),
                StartTime DATETIME2,
                EndTime DATETIME2,
                StatusMessage VARCHAR(1000)
            );
        END;

        ---------------------------------------------
        --- Resume operation
        ---------------------------------------------

        /*Check is there is operation to resume*/
        IF OBJECT_ID('dbo.AzureSQLMaintenanceCMDQueue') IS NOT NULL
        BEGIN
            IF
            /*resume information exists*/ EXISTS
            (
                SELECT *
                FROM dbo.AzureSQLMaintenanceCMDQueue
                WHERE ID = -1
            )
            BEGIN
                /*resume operation confirmed*/
                SET @operation = 'resume'; -- set operation to resume, this can only be done by the proc, cannot get this value as parameter

                -- restore operation parameters 
                SELECT TOP 1
                       @LogToTable = JSON_VALUE(ExtraInfo, '$.LogToTable'),
                       @mode = JSON_VALUE(ExtraInfo, '$.mode'),
                       @ResumableIndexRebuild = JSON_VALUE(ExtraInfo, '$.ResumableIndexRebuild')
                FROM dbo.AzureSQLMaintenanceCMDQueue
                WHERE ID = -1;

                RAISERROR('-----------------------', 0, 0);
                SET @msg = N'Resuming previous operation';
                RAISERROR(@msg, 0, 0);
                RAISERROR('-----------------------', 0, 0);
            END;
            ELSE
            BEGIN
                -- table [AzureSQLMaintenanceCMDQueue] exist but resume information does not exists
                -- this might happen in case execution intrupted between collecting index & ststistics information and executing commands.
                -- to fix that we drop the table now, it will be recreated later 
                DROP TABLE dbo.[AzureSQLMaintenanceCMDQueue];
            END;
        END;


        ---------------------------------------------
        --- Report operation parameters
        ---------------------------------------------

        /*Write operation parameters*/
        RAISERROR('-----------------------', 0, 0);
        SET @msg = N'set operation = ' + @operation;
        RAISERROR(@msg, 0, 0);
        SET @msg = N'set mode = ' + @mode;
        RAISERROR(@msg, 0, 0);
        SET @msg = N'set ResumableIndexRebuild = ' + CAST(@ResumableIndexRebuild AS VARCHAR(1));
        RAISERROR(@msg, 0, 0);
        SET @msg = N'set RebuildHeaps = ' + CAST(@RebuildHeaps AS VARCHAR(1));
        RAISERROR(@msg, 0, 0);
        SET @msg = N'set LogToTable = ' + CAST(@LogToTable AS VARCHAR(1));
        RAISERROR(@msg, 0, 0);
        IF @debug <> 'none'
        BEGIN
            SET @msg = N'set Debug = ' + CAST(@debug AS VARCHAR(20));
            RAISERROR(@msg, 0, 0);
        END;
        IF @WorkOnSchema IS NOT NULL
        BEGIN
            SET @msg = N'set Shcema = ' + CAST(@WorkOnSchema AS sysname);
            RAISERROR(@msg, 0, 0);
        END;
        RAISERROR('-----------------------', 0, 0);
    END;

    IF @LogToTable = 1
        INSERT INTO dbo.AzureSQLMaintenanceLog
        VALUES
        (@OperationTime, NULL, NULL, SYSDATETIME(), SYSDATETIME(),
         'Starting operation: Operation=' + @operation + ' Mode=' + @mode + ' Keep log for last '
         + CAST(@KeepXOperationInLog AS VARCHAR(10)) + ' operations');

    -- create command queue table, if there table exits then we resume operation in earlier stage.
    IF @operation != 'resume'
        CREATE TABLE dbo.AzureSQLMaintenanceCMDQueue
        (
            ID INT IDENTITY PRIMARY KEY,
            txtCMD NVARCHAR(MAX),
            ExtraInfo VARCHAR(MAX)
        );

    ---------------------------------------------
    --- Check if engine support resumable index operation
    ---------------------------------------------
    IF @ResumableIndexRebuild = 1
    BEGIN
        IF CAST(SERVERPROPERTY('EngineEdition') AS INT) >= 5
           OR CAST(SERVERPROPERTY('ProductMajorVersion') AS INT) >= 14
        BEGIN
            SET @ResumableIndexRebuildSupported = 1;
        END;
        ELSE
        BEGIN
            SET @ResumableIndexRebuildSupported = 0;
            SET @msg = N'Resumable index rebuild is not supported on this database';
            RAISERROR(@msg, 0, 0);
            IF @LogToTable = 1
                INSERT INTO dbo.AzureSQLMaintenanceLog
                VALUES
                (@OperationTime, NULL, NULL, SYSDATETIME(), SYSDATETIME(), @msg);
        END;
    END;


    ---------------------------------------------
    --- Index maintenance
    ---------------------------------------------
    IF @operation IN ( 'index', 'all' )
    BEGIN
        /**/
        IF @mode = 'smart'
           AND @RebuildHeaps = 1
            SET @indexStatsMode = 'SAMPLED';
        ELSE
            SET @indexStatsMode = 'LIMITED';

        RAISERROR('Get index information...(wait)', 0, 0) WITH NOWAIT;
        /* Get Index Information */
        SELECT idxs.[object_id],
               ObjectSchema = sc.name,
               ObjectName = SO.name,
               IndexName = idxs.name,
               idxs.type,
               idxs.type_desc,
               i.avg_fragmentation_in_percent,
               i.page_count,
               i.index_id,
               i.partition_number,
               i.avg_page_space_used_in_percent,
               i.record_count,
               i.ghost_record_count,
               i.forwarded_record_count,
               NULL AS OnlineOpIsNotSupported,
               NULL AS ObjectDoesNotSupportResumableOperation,
               CASE
                   WHEN ds.type = 'PS' THEN
                       1
                   ELSE
                       0
               END AS IsPartitioned,
               0 AS SkipIndex,
               CAST('' AS NVARCHAR(100)) AS IndexOperation,
               CAST('' AS NVARCHAR(MAX)) AS TSQLCommand,
               CAST('' AS NVARCHAR(MAX)) AS TSQLCommandExtraInfo,
               REPLICATE('', 128) AS SkipReason
        INTO #idxBefore
        FROM sys.indexes idxs
            INNER JOIN sys.objects [SO]
                ON [SO].object_id = [idxs].object_id
                   AND [SO].[type] IN ( 'U', 'V' )
            INNER JOIN sys.schemas sc
                ON sc.schema_id = SO.schema_id
            INNER JOIN sys.data_spaces ds
                ON idxs.data_space_id = ds.data_space_id
            LEFT JOIN sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, @indexStatsMode) i
                ON i.object_id = idxs.object_id
                   AND i.index_id = idxs.index_id
        WHERE idxs.type IN ( 0 /*HEAP*/, 1 /*CLUSTERED*/, 2 /*NONCLUSTERED*/, 5 /*CLUSTERED COLUMNSTORE*/, 6 /*NONCLUSTERED COLUMNSTORE*/ )
              AND
              (
                  alloc_unit_type_desc = 'IN_ROW_DATA' /*avoid LOB_DATA or ROW_OVERFLOW_DATA*/
                  OR alloc_unit_type_desc IS NULL /*for ColumnStore indexes*/
              )
              AND sc.name <> 'sys'
              AND
              (
                  @WorkOnSchema IS NULL
                  OR sc.name = @WorkOnSchema
              )
              AND idxs.is_disabled = 0
        ORDER BY i.avg_fragmentation_in_percent DESC,
                 i.page_count DESC;

        -- mark indexes XML,spatial and columnstore not to run online update 
        UPDATE #idxBefore
        SET OnlineOpIsNotSupported = 1
        WHERE [object_id] IN
              (
                  SELECT [object_id] FROM #idxBefore WHERE [type] = 3 /*XML Indexes*/
              );

        -- mark clustered indexes for tables with 'text','ntext','image' to rebuild offline
        UPDATE #idxBefore
        SET OnlineOpIsNotSupported = 1
        WHERE index_id = 1 /*clustered*/
              AND [object_id] IN
                  (
                      SELECT c.object_id
                      FROM sys.columns c
                          JOIN sys.types t
                              ON c.user_type_id = t.user_type_id
                      WHERE t.name IN ( 'text', 'ntext', 'image' )
                  );

        -- do all as offline for box edition that does not support online
        UPDATE #idxBefore
        SET OnlineOpIsNotSupported = 1
        WHERE /* Editions that does not support online operation in case this has been used with on-prem server */
            CONVERT(VARCHAR(100), SERVERPROPERTY('Edition')) LIKE '%Express%'
            OR CONVERT(VARCHAR(100), SERVERPROPERTY('Edition')) LIKE '%Standard%'
            OR CONVERT(VARCHAR(100), SERVERPROPERTY('Edition')) LIKE '%Web%';

        -- Do non resumable operation when index contains computed column or timestamp data type
        UPDATE idx
        SET ObjectDoesNotSupportResumableOperation = 1
        FROM #idxBefore idx
            JOIN sys.index_columns ic
                ON idx.object_id = ic.object_id
                   AND idx.index_id = ic.index_id
            JOIN sys.columns c
                ON ic.object_id = c.object_id
                   AND ic.column_id = c.column_id
        WHERE c.is_computed = 1
              OR c.system_type_id = 189; /*TimeStamp column*/

        -- set SkipIndex=1 if conditions for maintenance are not met
        -- this is used to idntify is stats need to be updated or not. 
        -- Check#1 - if table is too small
        UPDATE #idxBefore
        SET SkipIndex = 1,
            SkipReason = 'Maintenance is not needed as table is too small'
        WHERE (
            /*Table is small*/
            (page_count <= @minPageCountForIndex)
              )
              AND @mode <> 'dummy'; /*for Dummy mode we do not want to skip anything */

        -- Check#2 - if table is not small and fragmentation % is too low 
        UPDATE #idxBefore
        SET SkipIndex = 1,
            SkipReason = 'Maintenance is not needed as fragmentation % is low'
        WHERE (
            /*Table is big enough - but fragmentation is less than 5%*/
            (
                page_count > @minPageCountForIndex
                AND avg_fragmentation_in_percent < 5
            )
              )
              AND @mode <> 'dummy'; /*for Dummy mode we do not want to skip anything */

        -- Skip columnstore indexes
        UPDATE #idxBefore
        SET SkipIndex = 1,
            SkipReason = 'Columnstore index'
        WHERE (type IN (   5, /*Clustered columnstore index*/
                           6  /*Nonclustered columnstore index*/
                       )
              )
              AND @mode != 'dummy'; /*for Dummy mode we do not want to skip anything */

        /*Add information about dummy mode*/
        UPDATE #idxBefore
        SET TSQLCommandExtraInfo = TSQLCommandExtraInfo + 'Dummy mode '
        WHERE @mode = 'dummy'
              AND type <> 0;

        /* choose index operation Rebuild or Reorginize*/
        UPDATE #idxBefore
        SET IndexOperation = 'REORGANIZE ',
            TSQLCommandExtraInfo = TSQLCommandExtraInfo + 'columnstore index detected - reorginize'
        WHERE @mode = 'dummy'
              AND type IN ( 5, 6 ); /* Columnstore indexes in dummy mode -> reorganize them */

        UPDATE #idxBefore
        SET IndexOperation = 'REORGANIZE '
        WHERE avg_fragmentation_in_percent
              BETWEEN 5 AND 30
              AND @mode = 'smart' /* index fragmentation condition */
              AND type <> 0; /*avoid heaps*/

        -- all else should go for rebuild
        UPDATE #idxBefore
        SET IndexOperation = 'REBUILD '
        WHERE type NOT IN ( 0, 5, 6 ); /*Heaps and CS indexes*/

        UPDATE #idxBefore
        SET TSQLCommandExtraInfo = TSQLCommandExtraInfo + ' Current fragmentation: '
                                   + FORMAT(avg_fragmentation_in_percent / 100, 'p') + ' with '
                                   + CAST(page_count AS NVARCHAR(20)) + ' pages'
        WHERE IndexOperation <> '';

        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;
        RAISERROR('Index Information:', 0, 0) WITH NOWAIT;
        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;

        SELECT @msg = COUNT(*)
        FROM #idxBefore;
        SET @msg = N'Total Indexes: ' + @msg;
        RAISERROR(@msg, 0, 0) WITH NOWAIT;

        SELECT @msg = AVG(avg_fragmentation_in_percent)
        FROM #idxBefore
        WHERE page_count > @minPageCountForIndex;
        SET @msg = N'Average Fragmentation: ' + @msg;
        RAISERROR(@msg, 0, 0) WITH NOWAIT;

        SELECT @msg = SUM(IIF(avg_fragmentation_in_percent >= 5 AND page_count > @minPageCountForIndex, 1, 0))
        FROM #idxBefore;
        SET @msg = N'Fragmented Indexes: ' + @msg;
        RAISERROR(@msg, 0, 0) WITH NOWAIT;


        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;


        /* Choose the identifier to be used based on existing object name 
			this came up from object that contains '[' within the object name
			such as "EPK[export].[win_sourceofwealthbpf]" as index name
			if we use '[' as identifier it will cause wrong identifier name	
		*/
        IF EXISTS
        (
            SELECT 1
            FROM #idxBefore
            WHERE IndexName LIKE '%[%'
                  OR IndexName LIKE '%]%'
                  OR ObjectSchema LIKE '%[%'
                  OR ObjectSchema LIKE '%]%'
                  OR ObjectName LIKE '%[%'
                  OR ObjectName LIKE '%]%'
        )
        BEGIN
            SET @idxIdentifierBegin = '"';
            SET @idxIdentifierEnd = '"';
        END;
        ELSE
        BEGIN
            SET @idxIdentifierBegin = '[';
            SET @idxIdentifierEnd = ']';
        END;

        /* Build Index maintenance command  - Aletr index command */
        UPDATE #idxBefore
        SET TSQLCommand = 'ALTER INDEX ' + @idxIdentifierBegin + IndexName + @idxIdentifierEnd + ' ON '
                          + @idxIdentifierBegin + ObjectSchema + @idxIdentifierEnd + '.' + @idxIdentifierBegin
                          + ObjectName + @idxIdentifierEnd + ' '
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        /* Build Index maintenance command  - add rebuild or reorginize */
        UPDATE #idxBefore
        SET TSQLCommand = TSQLCommand + IndexOperation + ' ';

        /* Build Index maintenance command  - Rebuid or Reorginize */
        UPDATE #idxBefore
        SET TSQLCommand = TSQLCommand + CASE
                                            WHEN IsPartitioned = 1 THEN
                                                'PARTITION=' + CAST(partition_number AS NVARCHAR(MAX)) + ' '
                                            ELSE
                                                ''
                                        END
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        /* Build Index maintenance command  - MAXDOP and Online or offline */
        UPDATE #idxBefore
        SET TSQLCommand = TSQLCommand + 'WITH(MAXDOP=1,ONLINE=' + CASE
                                                                      WHEN OnlineOpIsNotSupported = 1 THEN
                                                                          'OFF'
                                                                      ELSE
                                                                          'ON'
                                                                  END
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        /* Build Index maintenance command  - Resumable Operation */
        UPDATE #idxBefore
        SET TSQLCommand = TSQLCommand + CASE
                                            WHEN @ResumableIndexRebuild = 1
                                                 AND ObjectDoesNotSupportResumableOperation = 0
                                                 AND @ResumableIndexRebuildSupported = 1 THEN
                                                'RESUMABLE=ON'
                                            ELSE
                                                ''
                                        END
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        /* Build Index maintenance command  - Closing the line of TSQL */
        UPDATE #idxBefore
        SET TSQLCommand = TSQLCommand + ');'
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        /* Tranfer commands to command queue table*/
        INSERT INTO dbo.AzureSQLMaintenanceCMDQueue
        (
            txtCMD,
            ExtraInfo
        )
        SELECT TSQLCommand,
               TSQLCommandExtraInfo
        FROM #idxBefore
        WHERE type != 0 /*avoid heaps*/
              AND SkipIndex = 0;

        ---------------------------------------------
        --- Index - Heaps 
        ---------------------------------------------

        /* create queue for heaps */
        IF @RebuildHeaps = 1
        BEGIN
            INSERT INTO dbo.AzureSQLMaintenanceCMDQueue
            (
                txtCMD,
                ExtraInfo
            )
            SELECT txtCMD = 'ALTER TABLE ' + @idxIdentifierBegin + ObjectSchema + @idxIdentifierEnd + '.'
                            + @idxIdentifierBegin + ObjectName + @idxIdentifierEnd + ' REBUILD;',
                   ExtraInfo = 'Rebuilding heap - forwarded records ' + CAST(forwarded_record_count AS VARCHAR(100))
                               + ' out of ' + CAST(record_count AS VARCHAR(100)) + ' record in the table'
            FROM #idxBefore
            WHERE type = 0 /*heaps*/
                  AND
                  (
                      @mode = 'dummy'
                      OR (forwarded_record_count / NULLIF(record_count, 0) > 0.3) /* 30% of record count */
                      OR (forwarded_record_count > 105000)/* for tables with > 350K rows dont wait for 30%, just run yje maintenance once we reach the 100K forwarded records */
                  );
        END; /* create queue for heaps */
    END;



    ---------------------------------------------
    --- Statistics maintenance
    ---------------------------------------------

    IF @operation IN ( 'statistics', 'all' )
    BEGIN
        /*Gets Stats for database*/
        RAISERROR('Get statistics information...', 0, 0) WITH NOWAIT;
        SELECT ObjectSchema = OBJECT_SCHEMA_NAME(s.object_id),
               ObjectName = OBJECT_NAME(s.object_id),
               s.object_id,
               s.stats_id,
               StatsName = s.name,
               sp.last_updated,
               sp.rows,
               sp.rows_sampled,
               sp.modification_counter,
               i.type,
               i.type_desc,
               0 AS SkipStatistics
        INTO #statsBefore
        FROM sys.stats s
            CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) sp
            LEFT JOIN sys.indexes i
                ON sp.object_id = i.object_id
                   AND sp.stats_id = i.index_id
        WHERE OBJECT_SCHEMA_NAME(s.object_id) != 'sys'
              AND
              (
                  @WorkOnSchema IS NULL
                  OR OBJECT_SCHEMA_NAME(s.object_id) = @WorkOnSchema
              )
              AND /*Modified stats or Dummy mode*/
              (
                  ISNULL(sp.modification_counter, 0) > 0
                  OR @mode = 'dummy'
              )
        ORDER BY sp.last_updated ASC;

        /*Remove statistics if it is handled by index rebuild / reorginize 
		I am removing statistics based on existance on the index in the list because for indexes with <5% changes we do not apply
		any action - therefore we might decide to update statistics */
        IF @operation = 'all'
            UPDATE _stats
            SET SkipStatistics = 1
            FROM #statsBefore _stats
                JOIN #idxBefore _idx
                    ON _idx.ObjectSchema = _stats.ObjectSchema
                       AND _idx.ObjectName = _stats.ObjectName
                       AND _idx.IndexName = _stats.StatsName
            WHERE _idx.SkipIndex = 0;

        /*Skip statistics for Columnstore indexes*/
        UPDATE #statsBefore
        SET SkipStatistics = 1
        WHERE type IN ( 5, 6 ); /*Column store indexes*/

        /*Skip statistics if resumable operation is pause on the same object*/
        IF @ResumableIndexRebuildSupported = 1
        BEGIN
            UPDATE _stats
            SET SkipStatistics = 1
            FROM #statsBefore _stats
                JOIN sys.index_resumable_operations iro
                    ON _stats.object_id = iro.object_id
                       AND _stats.stats_id = iro.index_id;
        END;

        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;
        RAISERROR('Statistics Information:', 0, 0) WITH NOWAIT;
        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;

        SELECT @msg = SUM(modification_counter)
        FROM #statsBefore;
        SET @msg = N'Total Modifications: ' + @msg;
        RAISERROR(@msg, 0, 0) WITH NOWAIT;

        SELECT @msg = SUM(IIF(modification_counter > 0, 1, 0))
        FROM #statsBefore;
        SET @msg = N'Modified Statistics: ' + @msg;
        RAISERROR(@msg, 0, 0) WITH NOWAIT;

        RAISERROR('---------------------------------------', 0, 0) WITH NOWAIT;

        /* Choose the identifier to be used based on existing object name */
        IF EXISTS
        (
            SELECT 1
            FROM #statsBefore
            WHERE StatsName LIKE '%[%'
                  OR StatsName LIKE '%]%'
                  OR ObjectSchema LIKE '%[%'
                  OR ObjectSchema LIKE '%]%'
                  OR ObjectName LIKE '%[%'
                  OR ObjectName LIKE '%]%'
        )
        BEGIN
            SET @statsIdentifierBegin = '"';
            SET @statsIdentifierEnd = '"';
        END;
        ELSE
        BEGIN
            SET @statsIdentifierBegin = '[';
            SET @statsIdentifierEnd = ']';
        END;

        /* create queue for update stats */
        INSERT INTO dbo.AzureSQLMaintenanceCMDQueue
        (
            txtCMD,
            ExtraInfo
        )
        SELECT txtCMD = 'UPDATE STATISTICS ' + @statsIdentifierBegin + ObjectSchema + +@statsIdentifierEnd + '.'
                        + @statsIdentifierBegin + ObjectName + @statsIdentifierEnd + ' (' + @statsIdentifierBegin
                        + StatsName + @statsIdentifierEnd + ') WITH FULLSCAN;',
               ExtraInfo = '#rows:' + CAST([rows] AS VARCHAR(100)) + ' #modifications:'
                           + CAST(modification_counter AS VARCHAR(100)) + ' modification percent: '
                           + FORMAT((1.0 * modification_counter / rows), 'p')
        FROM #statsBefore
        WHERE SkipStatistics = 0;
    END;

    IF @operation IN ( 'statistics', 'index', 'all', 'resume' )
    BEGIN

        DECLARE @SQLCMD NVARCHAR(MAX);
        DECLARE @ID INT;
        DECLARE @ExtraInfo NVARCHAR(MAX);

        /*Print debug information in case debug is activated */
        IF @debug != 'none'
        BEGIN
            DROP TABLE IF EXISTS idxBefore;
            DROP TABLE IF EXISTS statsBefore;
            DROP TABLE IF EXISTS cmdQueue;
            IF OBJECT_ID('tempdb..#idxBefore') IS NOT NULL
                SELECT *
                INTO dbo.idxBefore
                FROM #idxBefore;
            IF OBJECT_ID('tempdb..#statsBefore') IS NOT NULL
                SELECT *
                INTO dbo.statsBefore
                FROM #statsBefore;
            IF OBJECT_ID('AzureSQLMaintenanceCMDQueue') IS NOT NULL
                SELECT *
                INTO dbo.cmdQueue
                FROM dbo.AzureSQLMaintenanceCMDQueue;
        END;

        /*Save current execution parameters in case resume is needed */
        IF @operation != 'resume'
        BEGIN
            SET @ExtraInfo =
            (
                SELECT TOP 1
                       LogToTable = @LogToTable,
                       operation = @operation,
                       operationTime = @OperationTime,
                       mode = @mode,
                       ResumableIndexRebuild = @ResumableIndexRebuild,
                       debug = @debug
                FROM sys.tables
                FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
            );
            SET IDENTITY_INSERT AzureSQLMaintenanceCMDQueue ON;
            INSERT INTO dbo.AzureSQLMaintenanceCMDQueue
            (
                ID,
                txtCMD,
                ExtraInfo
            )
            VALUES
            (-1, 'parameters to be used by resume code path', @ExtraInfo);
            SET IDENTITY_INSERT AzureSQLMaintenanceCMDQueue OFF;
        END;

        ---------------------------------------------
        --- Executing commands
        ---------------------------------------------
        /*
		needed to rebuild indexes on comuted columns
		if ANSI_WARNINGS is set to OFF we might get the followin exception:
			Msg 1934, Level 16, State 1, Line 2
			ALTER INDEX failed because the following SET options have incorrect settings: 'ANSI_WARNINGS'. Verify that SET options are correct for use with indexed views and/or indexes on computed columns and/or filtered indexes and/or query notifications and/or XML data type methods and/or spatial index operations.
		*/
        SET ANSI_WARNINGS ON;

        RAISERROR('Start executing commands...', 0, 0) WITH NOWAIT;
        IF @debug = 'whatif'
            RAISERROR('*** whatif mode ***', 0, 0) WITH NOWAIT;
        DECLARE @T TABLE
        (
            ID INT,
            txtCMD NVARCHAR(MAX),
            ExtraInfo NVARCHAR(MAX)
        );
        WHILE EXISTS (SELECT * FROM dbo.AzureSQLMaintenanceCMDQueue WHERE ID > 0)
        BEGIN
            UPDATE TOP (1)
                dbo.AzureSQLMaintenanceCMDQueue
            SET txtCMD = txtCMD
            OUTPUT deleted.*
            INTO @T
            WHERE ID > 0;
            SELECT TOP (1)
                   @ID = ID,
                   @SQLCMD = txtCMD,
                   @ExtraInfo = ExtraInfo
            FROM @T;
            RAISERROR(@SQLCMD, 0, 0) WITH NOWAIT;
            IF @LogToTable = 1
                INSERT INTO AzureSQLMaintenanceLog
                VALUES
                (@OperationTime, @SQLCMD, @ExtraInfo, SYSDATETIME(), NULL, 'Started');
            BEGIN TRY
                IF @debug != 'whatif'
                    EXEC (@SQLCMD);
                IF @LogToTable = 1
                    UPDATE AzureSQLMaintenanceLog
                    SET EndTime = SYSDATETIME(),
                        StatusMessage = IIF(@debug = 'whatif', 'not executed - whatif mode', 'Succeeded')
                    WHERE id = SCOPE_IDENTITY();
            END TRY
            BEGIN CATCH
                SET @ScriptHasAnError = 1;
                SET @msg = N'FAILED : ' + CAST(ERROR_NUMBER() AS VARCHAR(50)) + ERROR_MESSAGE();
                RAISERROR(@msg, 0, 0) WITH NOWAIT;
                IF @LogToTable = 1
                    UPDATE AzureSQLMaintenanceLog
                    SET EndTime = SYSDATETIME(),
                        StatusMessage = @msg
                    WHERE id = SCOPE_IDENTITY();
            END CATCH;
            DELETE FROM AzureSQLMaintenanceCMDQueue
            WHERE ID = @ID;
            DELETE FROM @T;
        END;
        DROP TABLE AzureSQLMaintenanceCMDQueue;
    END;

    ---------------------------------------------
    --- Clean old records from log table
    ---------------------------------------------
    IF @LogToTable = 1
    BEGIN
        DELETE FROM dbo.AzureSQLMaintenanceLog
        FROM dbo.AzureSQLMaintenanceLog L
            JOIN
            (
                SELECT DISTINCT
                       OperationTime
                FROM dbo.AzureSQLMaintenanceLog
                ORDER BY OperationTime DESC OFFSET @KeepXOperationInLog ROWS
            ) F
                ON L.OperationTime = F.OperationTime;
        INSERT INTO dbo.AzureSQLMaintenanceLog
        VALUES
        (@OperationTime, NULL,
         CAST(@@rowcount AS VARCHAR(100))
         + ' rows purged from log table because number of operations to keep is set to: '
         + CAST(@KeepXOperationInLog AS VARCHAR(100)), SYSDATETIME(), SYSDATETIME(), 'Cleanup Log Table');
    END;

    IF @ScriptHasAnError = 0
        RAISERROR('Done', 0, 0);
    IF @LogToTable = 1
        INSERT INTO dbo.AzureSQLMaintenanceLog
        VALUES
        (@OperationTime, NULL, NULL, SYSDATETIME(), SYSDATETIME(), 'End of operation');
    IF @ScriptHasAnError = 1
        RAISERROR('Script has errors - please review the log.', 16, 1);
END;
GO
PRINT 'Execute AzureSQLMaintenance to get help';


/*
Examples

1. run through all indexes and statistic and take smart decision about steps taken for each object
exec  AzureSQLMaintenance 'all'

1.1 add log to table
exec  AzureSQLMaintenance 'all', @LogToTable=1, @ResumableIndexRebuild=1


2. run through all indexes and statistic with no limitation (event non modified object will be rebuild or updated)
exec  AzureSQLMaintenance 'all','dummy'


3. run smart maintenance only for statistics
exec  AzureSQLMaintenance 'statistics'


4. run smart maintenance only for indexes
exec  AzureSQLMaintenance 'index'

*/
